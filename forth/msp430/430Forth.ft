\ vim:ft=forth:ts=2:sw=2:expandtab:foldmethod=marker:foldmarker=\\\ --\ ,\\\ ---:

\ -----------------------------------------------------------------------------
\ -- Constants, variables and memory buffers

$C000 constant init-cold
$C002 constant init-latest
$C004 constant init-dp
$C006 constant init-vp

$0200 constant latest
$0202 constant dp
$0204 constant vp
$0206 constant state
$0208 constant (source)
$020A constant source#
$020C constant >in
$020E constant current
$0210 constant base
$0212 constant hp
$0214 constant tib

$0080 constant tib#
$0400 constant ram-top
$0020 constant bl
$ED00 constant cpuid
$0400 constant s0
$03C0 constant r0

\ -----------------------------------------------------------------------------
\ -- Machine interface

code docol      $4136 $1205 $4605 $4530 end-code
code reset-handler
                $40b2 $5a80 $0120
                $42d2 $10fd $0057 $42d2 $10fc $0056 $43c2 $0058
                $4307 $4034 $0400 $4031 $0380 $4035 $c000
                $4536 $4600 end-code
code halt       $3fff $4530 end-code
code bye        $3fff end-code
code wfi        $3fff end-code

\ Compiler and control flow

code lit        $8324 $4784 $0000 $4537 $4530 end-code
code branch     $4525 $4530 end-code
code ?branch    $5307 $4437 $2402 $5325 $4530 $4525 $4530 end-code
code exit       $4135 $4530 end-code
code execute    $4706 $4437 $4600 end-code

\ -----------------------------------------------------------------------------
\ -- Stack operations

code dup        $8324 $4784 $0000 $4530 end-code
code drop       $4437 $4530 end-code
code swap       $4426 $4784 $0000 $4607 $4530 end-code
code over       $4426 $8324 $4784 $0000 $4607 $4530 end-code
code rot        $4426 $4784 $0000 $4417 $0002 $4684 $0002 $4530 end-code
code ?dup       $9307 $2001 $4530 $8324 $4784 $0000 $4530 end-code
code nip        $5324 $4530 end-code

code >r         $1207 $4437 $4530 end-code
code r>         $8324 $4784 $0000 $4137 $4530 end-code
code r@         $8324 $4784 $0000 $4127 $4530 end-code
code rdrop      $5321 $4530 end-code

code sp@        $8324 $4784 $0000 $4407 $4530 end-code
code rp@        $8324 $4784 $0000 $4107 $4530 end-code
code sp!        $4704 $4437 $4530 end-code
code rp!        $4701 $4437 $4530 end-code

: 2dup          over over ;
: tuck          swap over ;
: -rot          rot rot ;
: 2drop         drop drop ;
: 2swap         rot >r rot r> ;

\ -----------------------------------------------------------------------------
\ -- Memory operations

code c@         $4767 $4530 end-code
code c!         $4436 $46c7 $0000 $4437 $4530 end-code
code h@         $4727 $4530 end-code
code h!         $44b7 $0000 $4437 $4530 end-code
code @          $4727 $4530 end-code
code !          $44b7 $0000 $4437 $4530 end-code

\ -----------------------------------------------------------------------------
\ -- Logical operators

code and        $f437 $4530 end-code
code or         $d437 $4530 end-code
code invert     $e337 $4530 end-code
code not        $8317 $7707 $4530 end-code
code xor        $e437 $4530 end-code
code aligned    $5317 $c317 $4530 end-code

code bis!       $3fff $4530 end-code
code bic!       $3fff $4530 end-code
code xor!       $3fff $4530 end-code
code bis        $3fff $4530 end-code
code bic        $3fff $4530 end-code
code bit@       $3fff $4530 end-code

\ -----------------------------------------------------------------------------
\ -- Arithmetic

code +          $5437 $4530 end-code
code -          $4436 $8706 $4607 $4530 end-code
code um*        $442a $430c $430d $430b $4316 $b607 $2402 $5a0c
                $6b0d $5a0a $6b0b $5606 $2bf8 $4c84 $0000 $4d07
                $4530 end-code
code u/mod      $430b $442a $430c $4036 $0011 $970b $2801 $870b $6c0c
                $2c09 $8316 $2406 $5a0a $6b0b $2bf6 $870b $d312
                $3ff6 $c312 $4b84 $0000 $4c07 $4530 end-code
code um/mod     $443b $442a $430c $4036 $0011 $970b $2801 $870b $6c0c
                $2c09 $8316 $2406 $5a0a $6b0b $2bf6 $870b $d312
                $3ff6 $c312 $4b84 $0000 $4c07 $4530 end-code
code abs        $9307 $3402 $e337 $5317 $4530 end-code

code 1+         $5317 $4530 end-code
code 2+         $5327 $4530 end-code
code 4+         $5227 $4530 end-code
code 1-         $8317 $4530 end-code
code 2-         $8327 $4530 end-code
code 4-         $8227 $4530 end-code
code char+      $5317 $4530 end-code
code cell+      $5327 $4530 end-code
code char-      $8317 $4530 end-code
code cell-      $8327 $4530 end-code
code 2/         $1107 $4530 end-code
code 2*         $5707 $4530 end-code
code cells      $5707 $4530 end-code
code chars      $4530 end-code
code 1          $8324 $4784 $0000 $4317 $4530 end-code
code 2          $8324 $4784 $0000 $4327 $4530 end-code
code cell       $8324 $4784 $0000 $4327 $4530 end-code

code lshift     $4436 $f037 $001f $2403 $5606 $8317 $23fd $4607 $4530 end-code
code rshift     $4436 $f037 $001f $2404 $c312 $1006 $8317 $23fc $4607 $4530 end-code
code shl        $3fff $4530 end-code
code shr        $3fff $4530 end-code

code 0=         $8317 $7707 $4530 end-code
code 0<>        $8317 $7707 $e337 $4530 end-code
code 0<         $9307 $3402 $4337 $4530 $4307 $4530 end-code
code 0<=        $9307 $2403 $2802 $4307 $4530 $4337 $4530 end-code
code 0>         $9317 $3402 $4307 $4530 $4337 $4530 end-code
code 0>=        $9307 $3402 $4307 $4530 $4337 $4530 end-code
code =          $4436 $8706 $2402 $4307 $4530 $4337 $4530 end-code
code <          $4436 $8706 $3402 $4337 $4530 $4307 $4530 end-code
code u<         $4436 $8706 $2802 $4307 $4530 $4337 $4530 end-code
code m+         $5784 $0002 $6384 $0000 $4437 $4530 end-code

: s>d           dup 0< ;
: dnegate       swap invert swap invert 1 m+ ;
: ?dnegate      0< if dnegate then ;
: m*            2dup xor >r swap abs swap abs um* r> ?dnegate ;
: u*            um* drop ;
: *             m* drop ;

: 2c@           c@ swap c@ swap ;
: +!            dup @ rot + swap ! ;
: -!            dup @ rot - swap ! ;

: /             u/mod nip ;
: umod          u/mod drop ;
: mod           u/mod drop ;
: >             swap < ;
: u>            swap u< ;
: <>            = invert ;
: <=            > invert ;
: >=            < invert ;
: within        over - >r - r> u< ;

: true          0 invert ;
: false         0 ;
: negate        invert 1+ ;

: umin          2dup u> if swap then drop ;
: umax          2dup u< if swap then drop ;
: min           2dup > if swap then drop ;
: max           2dup < if swap then drop ;

: 2@            dup @ cell+ @ ;
: 2!            tuck ! cell+ ! ;

: pick          ?dup if 1- cells sp@ + @ else dup then ;
: 2over         >r >r 2dup r> r> 2swap ;

\ -----------------------------------------------------------------------------
\ -- Strings and chars

: uppercase     dup $61 $7B within $20 and xor ;
: /string       rot over + -rot - ;
: 1/string      1- swap 1+ swap ;
: count         dup 1+ swap c@ ;
: ci@=          c@ uppercase swap c@ uppercase = ;
: cappend       1 over +! dup c@ + c! ;
: digit?        dup $39 > $80 2*  and +
                dup $A0 2* > $83 2* 1+ and -
                $30 - dup base @ u< ;

\ -----------------------------------------------------------------------------
\ -- Compiler

: here          dp @ ;
: allot         here + dp ! ;
: org           dp ! ;
: ,             here ! cell allot ;
: c,            here c! 1 allot ;

: [             false state ! ; immediate
: ]             true state ! ;
: ,call         , ;
: literal       postpone lit , ; immediate

\ -----------------------------------------------------------------------------
\ -- Control flow

: if            postpone ?branch here cell allot ; immediate
: else          postpone branch here cell allot here rot ! ; immediate
: then          here swap ! ; immediate
: begin         here ; immediate
: again         postpone branch , ; immediate
: until         postpone ?branch , ; immediate
: while         postpone ?branch here cell allot ; immediate
: repeat        swap postpone branch ,
                here swap ! ; immediate

: (do)          r> -rot >r 1- >r >r ;
: i             r> r> r@ -rot >r >r ;
: j             rp@ 4 cells + @ ;
: unloop        r> rdrop rdrop >r ;
: (loop)        r> r> r> 1+ 2dup < if 2drop true else >r >r false then
                swap >r ;
: do            postpone (do) here ; immediate
: loop          postpone (loop)
                postpone ?branch , ; immediate

\ -----------------------------------------------------------------------------
\ -- Strings and chars continued

: si=           ( c-addr1 c-addr2 -- f )
                dup c@ 1+ begin >r 2dup ci@= r> tuck and while
                  1- rot 1+ rot 1+ rot
                repeat -rot 2drop 0= ;

\ -----------------------------------------------------------------------------
\ -- Input handling

: pad           vp @ $10 + ;
: wp            pad $40 + ;
: source@       (source) @ >in @ + c@ ;
: >>source      1 >in +! ;
: in-source?    >in @ source# @ < ;
: skip          begin source@ over = in-source? and while >>source repeat drop ;
: copy          begin source@ over <> in-source? and while
                  source@ wp cappend   >>source
                repeat in-source? if >>source then drop ;
: word          0 wp tuck c! swap dup skip copy ;
: char          bl word 1+ c@ ;

\ -----------------------------------------------------------------------------
\ -- Input/Output

code emit       $b3e2 $0003 $27fd $47c2 $0067 $4437 $4530 end-code
code key        $b3d2 $0003 $27fd $8324 $4784 $0000 $4257 $0066 $4530 end-code
code key?       $8324 $4784 $0000 $b3d2 $0003 $2002 $4307 $4530 $4337 $4530 end-code

: count         dup 1+ swap c@ ;
: cr            #13 emit #10 emit ;
: space         bl emit ;
: spaces        begin ?dup 0> while space 1- repeat ;
: type          begin dup 0> while swap dup c@ emit 1+ swap 1- repeat 2drop ;
: xon           $11 emit ;
: xoff          $13 emit ;

: <#            pad hp ! ;
: hold          1 hp -! hp @ c! ;
: >digit        dup 9 > 7 and + #48 + ;
: #             base @ u/mod swap >digit hold ;
: #s            begin # dup 0= until ;
: #>            drop hp @ pad over - ;
: sign          0< if $2D hold then ;
: u.            <# #s #> type space ;
: .             <# dup abs #s swap sign #> type space ;

: binary        #2 base ! ;
: octal         #8 base ! ;
: decimal       #10 base ! ;
: hex           #16 base ! ;

: hex. ( n -- ) base @ swap hex <# # # # # # # # # #> type base ! ;
: h.4  ( n -- ) base @ swap hex <# # # # # #> type base ! ;
: h.2  ( n -- ) base @ swap hex <# # # #> type base ! ;

: accept        ( c-addr +n -- +n'   get line from terminal )
                over + 1- over
                begin key
                dup $0A <> while
                  dup emit
                  dup 8 = if  drop 1-  >r over r> umax
                          else  over c!  1+ over umin
                  then
                repeat
                drop nip swap - ;

: depth         s0 sp@ - 2/ 1- 1- ;
: .s            sp@ begin dup s0 cell- < while dup @ u. cell+ repeat drop ;
: .r            rp@ begin dup r0 cell- < while dup @ u. cell+ repeat drop ;

\ -----------------------------------------------------------------------------
\ -- Memory continued

: fill          swap >r swap begin r@ 0>
                  while 2dup c! 1+ r> 1- >r
                repeat
                rdrop 2drop ;
: move          >r begin r@ 0> while
                  over @ over ! cell+ swap cell+ swap
                  r> cell- >r
                repeat rdrop 2drop ;
: cmove         >r begin r@ 0> while
                  over c@ over c! 1+ swap 1+ swap
                  r> 1- >r
                repeat rdrop 2drop ;

\ -----------------------------------------------------------------------------
\ -- Dictionary

: align         here aligned org ;
: imove         move ;
: link>name     4 + ;
: link>flags    2 + ;
: >body         $10 + ;
: link>         link>name dup c@ + 1+ aligned ;
: ,link         , ;
: find          >r latest begin
                  @ dup if dup link>name r@ si= over current @ <> and
                  else r@ swap true
                  then
                until rdrop
                dup if
                  dup link>
                  swap link>flags c@ $FE <> 1 or
                then ;
: '             bl word find dup 0= if drop count type space $3F emit
                else drop then ;

\ -----------------------------------------------------------------------------
\ -- Compiler

: <builds       align   here latest dup @ ,link  2 allot !
                bl word
                dup dup c@ 1+ here swap imove
                c@ 1+ allot align ;
: ,enter        $12b0 , ['] docol , ;
: ,exit         ['] exit , ;
: immediate     $FE latest @ link>flags c! ;
: hide          latest @ current ! ;
: reveal        0 current ! ;
: postpone      bl word find 0< if literal postpone ,call
                else ,call then ; immediate
: [']           ' postpone literal ; immediate

: :             <builds ,enter hide ] ;
: ;             ,exit reveal [ ; immediate
: :noname       align latest @ here latest ! ]  , here ; immediate

: docon         ;
: dodata        ;
: dodefer       ;
: create        <builds dodata here , ;
: constant      <builds docon align , ;
: variable      <builds docon align vp dup @ dup , cell+ swap ! ;
: defer         <builds $FFFF , 6 allot ; immediate
: is            ' $FFFF over ! cell+ ! ; immediate

: (does>)       here r> 1- latest @ link> #10 + org $B500 , ,call org ;
: does>         postpone (does>) ; immediate
: recurse       latest @ link> ,call ; immediate
: [char]        char postpone literal ; immediate
\ : (             [char] ) word drop ; immediate
\ : \             source# @ >in ! ; immediate
: setbase       ( addr n -- addr' n' )
                over c@ dup 0<> and
                dup [char] $ = if drop $10 else
                dup [char] # = if drop $0A else
                    [char] % = if $02 else exit
                then then then base ! 1/string ;
: ?sign         ( addr n --  addr' n' f )
                over c@ $2C - dup abs 1 = and
                dup if 1+ >r 1/string r> then ;
: >number       ( u addr u --  u' addr' u' )
                setbase
                begin dup while
                  over c@ digit? 0= if drop exit then
                  >r rot base @ * r> + -rot
                  1/string
                repeat ;
: ?number       ( c-addr -- n -1 | c-addr 0 )
                base @ >r
                dup 0 0 rot count
                ?sign >r >number if rdrop 2drop drop 0
                else 2swap 2drop drop r> if negate then
                true then r> base ! ;
: (s")          r> count 2dup + aligned >r ;
: s"            postpone (s")
                [char] " word dup dup c@ 1+ here swap imove
                c@ 1+ allot align ; immediate
\ : ."            postpone s" postpone type ; immediate

\ -----------------------------------------------------------------------------
\ -- High level hardware interface

$20 constant P1IN
$21 constant P1OUT
$22 constant P1DIR
$23 constant P1IFG
$24 constant P1IES
$25 constant P1IE
$26 constant P1SEL
$27 constant P1REN
$41 constant P1SEL2

$60 constant UCA0CTL0
$61 constant UCA0CTL1
$62 constant UCA0BR0
$63 constant UCA0BR1
$64 constant UCA0MCTL
$65 constant UCA0STAT
$66 constant UCA0RXBUF
$67 constant UCA0TXBUF

: setup-ports   %00001000 P1OUT c!
                %00001000 P1REN c!
                %01000101 P1DIR c!
                %00000110 dup P1SEL c! P1SEL2 c! ;

: setup-uart    %00000001 UCA0CTL1 c!
                %00000000 UCA0CTL0 c!
                %10000001 UCA0CTL1 c!
                #65 UCA0BR0 c!   #3 UCA0BR1 c!
                %00000100 UCA0MCTL c!
                %10000000 UCA0CTL1 c!
                $1000 begin 1- dup 0= until drop ;

: setup-hw      setup-ports   setup-uart ;

\ -----------------------------------------------------------------------------
\ -- Interpreter

: setup-pointers
                init-dp @ dp !
                init-vp @ vp !
                init-latest @ latest !
                ;

: prompt        [char] o emit [char] k emit cr ;
: source        (source) @ source# @ ;
: (interpret)   begin  bl word  dup c@ while      \ textadr
                  find ?dup if                    \ xt 1/-1
                    1+ state @ 0= or              \ immed or interp?
                    if execute else ,call then
                  else                            \ textadr
                    ?number if                    \ converted ok
                      state @ if postpone literal then
                    else count type [char] ? emit cr then  \ error
                  then
                repeat drop ;
: evaluate      source# !  (source) ! 0 >in !  (interpret) ;
: quit          \ r0 rp! 0 state !    \ reset stacks, state
                0 state !
                setup-pointers
                setup-hw
                s" 430Forth XXXXXXXX ready" type cr
                begin
                  xon
                  tib dup tib# accept space
                  xoff
                  evaluate
                  state @ 0= if space prompt then
                again ;

: abort         \ s0 sp! #16 base ! quit ;
                #16 base ! quit ;
: cold          abort ;

\ -----------------------------------------------------------------------------
\ -- Utilities

: words         latest begin @ ?dup while
                  dup link>name count type space
                repeat ;
: list          latest begin @ ?dup while
                  dup link> u. dup link>name count type cr
                repeat ;

: dump          >r dup cr hex. space begin
                r@ while
                  dup c@ h.2 space 1+
                  r> 1- dup $10 mod 0= over and if cr over hex. space then >r
                repeat rdrop drop ;

: dumph         >r dup cr hex. space begin
                r@ while
                  dup h@ h.4 space 2+
                  r> 1- dup $8 mod 0= over and if cr over hex. space then >r
                repeat rdrop drop ;

: dumpw         >r dup cr hex. space begin
                r@ while
                  dup @ hex. space cell+
                  r> 1- dup $4 mod 0= over and if cr over hex. space then >r
                repeat rdrop drop ;

include common.ft
